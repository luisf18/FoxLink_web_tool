<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Web AVR Uploader</title>

<style>
:root {
    --orange: #ff7a00;
    --orange-dark: #e06600;
    --green: #2ecc71;
    --red: #e74c3c;
}

body {
    font-family: monospace;
    background: #fff;
    color: #000;
    margin: 20px;
}

h2 {
    color: var(--orange);
}

button, select, input {
    font-family: monospace;
    padding: 6px 10px;
    border-radius: 4px;
    border: 1px solid var(--orange);
}

button {
    cursor: pointer;
    color: #fff;
    font-weight: bold;
}

#connectBtn {
    background: var(--red);
}

#connectBtn.connected {
    background: var(--green);
}

#uploadBtn {
    background: var(--orange);
}

button:hover {
    opacity: 0.9;
}

progress {
    width: 100%;
    height: 16px;
    margin-top: 10px;
    appearance: none;
}

progress::-webkit-progress-bar {
    background: #eee;
    border-radius: 6px;
}

progress::-webkit-progress-value {
    background: var(--orange);
    border-radius: 6px;
}

#log {
    margin-top: 15px;
    background: #000;
    color: #00ff00;
    padding: 10px;
    height: 260px;
    overflow-y: auto;
    white-space: pre;
    border-radius: 4px;
}
</style>
</head>

<body>

<h2>Web AVR Uploader</h2>

<input type="file" id="fwFile" accept=".hex,.bin"><br><br>

<label>Placa:</label>
<select id="board">
    <option value="uno">Arduino Uno / Nano (ATmega328)</option>
</select><br><br>

<label>Bin:</label>
<select id="binSelect"></select><br><br>

<button id="connectBtn">Desconectado</button>
<button id="uploadBtn">Upload</button>

<progress id="progress" value="0" max="100"></progress>

<div id="log"></div>

<script>
/* ================= CONFIG ================= */

const BOARDS = {
    uno: { baud:115200, flash:32*1024, page:128 }
};

/* ================= STATE ================= */

let port, reader, writer;
let bins = [];
let connected = false;

/* ================= LOG ================= */

function log(msg) {
    const el = document.getElementById("log");
    el.textContent += msg + "\n";
    el.scrollTop = el.scrollHeight;
}

/* ================= INTEL HEX ================= */

function parseIntelHex(text) {
    let mem = {}, base = 0;

    for (const line of text.split(/\r?\n/)) {
        if (!line.startsWith(":")) continue;

        const len = parseInt(line.substr(1,2),16);
        const addr = parseInt(line.substr(3,4),16);
        const type = parseInt(line.substr(7,2),16);
        const data = line.substr(9,len*2);

        if (type === 0x00)
            for (let i=0;i<len;i++)
                mem[base+addr+i] = parseInt(data.substr(i*2,2),16);

        else if (type === 0x04)
            base = parseInt(data,16)<<16;
    }

    const addrs = Object.keys(mem).map(Number).sort((a,b)=>a-b);
    let blocks=[], start=null, buf=[];

    for (let i=0;i<addrs.length;i++) {
        const a=addrs[i];
        if (start===null || a!==addrs[i-1]+1) {
            if (buf.length) blocks.push({addr:start,data:[...buf],len:buf.length});
            start=a; buf=[];
        }
        buf.push(mem[a]);
    }
    if (buf.length) blocks.push({addr:start,data:[...buf],len:buf.length});

    return blocks;
}

/* ================= FILE LOAD ================= */

fwFile.onchange = async ()=>{
    bins=[];
    const file=fwFile.files[0];
    if(!file) return;

    if(file.name.endsWith(".hex"))
        bins=parseIntelHex(await file.text());
    else {
        const b=await file.arrayBuffer();
        bins=[{addr:0,data:[...new Uint8Array(b)],len:b.byteLength}];
    }

    log(`Arquivo: ${file.name}`);
    binSelect.innerHTML="";
    bins.forEach((b,i)=>{
        log(`BIN ${i}: addr=0x${b.addr.toString(16)} size=${b.len}`);
        const o=document.createElement("option");
        o.value=i;
        o.textContent=`BIN ${i} @0x${b.addr.toString(16)} (${b.len} B)`;
        binSelect.appendChild(o);
    });
};

/* ================= SERIAL ================= */

async function connect() {
    port=await navigator.serial.requestPort();
    await port.open({baudRate:BOARDS[board.value].baud});
    writer=port.writable.getWriter();
    reader=port.readable.getReader();
    connected=true;

    connectBtn.textContent="Conectado";
    connectBtn.classList.add("connected");
    log("Serial conectada");
}

async function disconnect() {
    reader.releaseLock();
    writer.releaseLock();
    await port.close();
    connected=false;

    connectBtn.textContent="Desconectado";
    connectBtn.classList.remove("connected");
    log("Serial desconectada");
}

connectBtn.onclick=async()=>{
    connected ? await disconnect() : await connect();
};

/* ================= STK500 UPLOAD ================= */

async function upload(bin) {
    const page=BOARDS[board.value].page;
    const total=bin.len;
    const startTime=performance.now();
    progress.value=0;

    log("Upload iniciado");

    for(let i=0;i<total;i+=page){
        const chunk=bin.data.slice(i,i+page);
        const word=(bin.addr+i)>>1;

        await writer.write(new Uint8Array([0x55,word&0xFF,(word>>8)&0xFF,0x20]));
        await writer.write(new Uint8Array([0x64,chunk.length>>8,chunk.length&0xFF,0x46]));
        await writer.write(new Uint8Array(chunk));
        await writer.write(new Uint8Array([0x20]));

        progress.value=Math.floor((i+chunk.length)/total*100);
        await new Promise(r=>setTimeout(r,3));
    }

    const t=((performance.now()-startTime)/1000).toFixed(2);
    progress.value=100;
    log(`Upload finalizado em ${t}s`);
}

uploadBtn.onclick=async()=>{
    if(!connected) return alert("Conecte primeiro");
    await upload(bins[binSelect.value]);
};
</script>

</body>
</html>
